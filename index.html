<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script src="./webgl-helper.js"></script>
  <script src="./webgl-matrix.js"></script>
  <script type="shader-source" id="vertexShader">
    precision mediump float;
    attribute vec3 a_Position;
    attribute vec4 a_Color;
    varying vec4 v_Color;
    uniform mat4 u_Matrix;

    void main() {
      gl_Position = u_Matrix * vec4(a_Position, 1.0);
      v_Color = a_Color;
    }
  </script>
  <script type="shader-source" id="fragmentShader">
    precision mediump float;
    varying vec4 v_Color;

    void main() {
      gl_FragColor = v_Color;
    }
  </script>
  <script type="text/javascript">
    var canvas = getCanvas('canvas')
    var gl = getWebGLContext(canvas)

    var vertexShader = createShaderFromScript(gl, gl.VERTEX_SHADER, 'vertexShader')
    var fragmentShader = createShaderFromScript(gl, gl.FRAGMENT_SHADER, 'fragmentShader')

    var program = createProgram(gl, vertexShader, fragmentShader)
    gl.useProgram(program)

    var u_Matrix = gl.getUniformLocation(program, 'u_Matrix')
    var a_Color = gl.getAttribLocation(program, 'a_Color')
    var a_Position = gl.getAttribLocation(program, 'a_Position')
    gl.enableVertexAttribArray(a_Position)
    gl.enableVertexAttribArray(a_Color)

    var buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 28, 0)
    gl.vertexAttribPointer(a_Color, 4, gl.FLOAT, false, 28, 12)

    var indicesBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer)

    var CUBE_FACE_INDICES = [
      [0, 1, 2, 3], // 前
      [4, 5, 6, 7], // 后
      [0, 3, 5, 4], // 左
      [1, 7, 6, 2], // 右
      [3, 2, 6, 5], // 上
      [0, 4, 7, 1]  // 下
    ]

    var FACE_COLORS = [
      [1, 0, 0, 1], // 前 红
      [0, 1, 0, 1], // 后 绿
      [0, 0, 1, 1], // 左 蓝
      [1, 1, 0, 1], // 右 黄
      [1, 0, 1, 1], // 上 品
      [0, 1, 1, 1]  // 下 青
    ]
    let cube = createCube(1, 1, 1)

    gl.bufferData(gl.ARRAY_BUFFER, cube.positions, gl.STATIC_DRAW)
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube.indices, gl.STATIC_DRAW)

    gl.clearColor(0.0, 0.0, 0.0, 1.0)
    gl.clear(gl.COLOR_BUFFER_BIT)
    gl.enable(gl.CULL_FACE)


    var aspect = canvas.width / canvas.height
    var projectionMatrix = matrix.ortho(-aspect * 4, aspect * 4, -4, 4, 100, -100)
    var dstMatrix = matrix.identity()
    var tmpMatrix = matrix.identity()
    var xAngle = 0
    var yAngle = 0
    var deg = Math.PI / 180
    var timer = null

    animate()

    function animate(e) {
      if (timer) {
        clearInterval(timer)
        timer = null
      } else {
        timer = setInterval(() => {
          xAngle += 1
          yAngle += 1

          matrix.rotationY(deg * yAngle, dstMatrix)
          matrix.multiply(dstMatrix, matrix.rotationX(deg * xAngle, tmpMatrix), dstMatrix)
          matrix.multiply(projectionMatrix, dstMatrix, dstMatrix)
          gl.uniformMatrix4fv(u_Matrix, false, dstMatrix)
          gl.clear(gl.COLOR_BUFFER_BIT)
          gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0)
        }, 50)
      }
    }

    function createCube(width, height, depth) {
      let zeroX = width / 2
      let zeroY = height / 2
      let zeroZ = depth / 2

      let cornerPositions = [
        [-zeroX, -zeroY, zeroZ],
        [zeroX, -zeroY, zeroZ],
        [zeroX, zeroY, zeroZ],
        [-zeroX, zeroY, zeroZ],
        [-zeroX, -zeroY, -zeroZ],
        [-zeroX, zeroY, -zeroZ],
        [zeroX, zeroY, -zeroZ],
        [zeroX, -zeroY, -zeroZ]
      ]

      let positions = []
      let indices = []

      for (let f = 0; f < 6; f++) {
        let faceIndices = CUBE_FACE_INDICES[f]
        let color = FACE_COLORS[f]
        for (let v = 0; v < 4; v++) {
          let position = cornerPositions[faceIndices[v]]
          positions = positions.concat(position)
          positions = positions.concat(color)
        }
        let offset = 4 * f
        indices.push(offset + 0, offset + 1, offset + 2)
        indices.push(offset + 0, offset + 2, offset + 3)
      }
      indices = new Uint16Array(indices)
      positions = new Float32Array(positions)
      return {
        positions,
        indices
      }
    }

  </script>
</body>
</html>